/* local (hidden) function calls + structures */

static Canvas cv;


static void icsgl_error() {
	GLenum error;

	while ( (error = glGetError()) != GL_NO_ERROR ) {
		fprintf(stderr,"  ## ERROR: %d: %s\n",(int)error,(char*)gluErrorString(error));
		exit(1);
	}
}

/* identify active scene id */
static int view_id() {
  int i,idw;

  assert(cv.ids>=0);
  idw = glutGetWindow();

  for (i=0; i<IGL_MAX_VIEW; i++) {
    if ( idw == cv.view[i]->id )
      return(i);
  }
	if ( cv.ddb )  fprintf(stderr,"  ## ERROR: view not found.");
	return(-1);
}

/* project point onto hemi-sphere */
static void view_proj(int dx,int dy,int w,int h,float *v) {
  double   d1,d2;

  v[0] =  2.0*(float)dx / (float)w;
  v[1] = -2.0*(float)dy / (float)h;
  v[2] =  1.0;
  d1 = v[0]*v[0] + v[1]*v[1];
  if ( d1 > 0.0 ) {
    d2 = sqrt(d1);
		if ( d2 > 1.0 )  d2 = 1.0;
    v[2] = cos(M_PI_2 * d2);
    d1  += v[2]*v[2];
    d1   = 1.0 / sqrt(d1);
    v[0] *= d1;  
    v[1] *= d1;  
    v[2] *= d1;
  }
}

static void view_motion(int x,int y) {
  View    *vw;
  Mouse   *m;
  GLuint   tm;
	float    pos[3],dx,dy,dz;
  int      id,ix,iy;

  if ( cv.ddb )  fprintf(stdout,"  - control mouse (%d,%d)\n",x,y);
	id = view_id();
  assert(id > -1);
  vw = cv.view[id];
  m  = &cv.mouse;

  /* filter event when moving */
  tm = glutGet(GLUT_ELAPSED_TIME);
printf(" tm %d   mtm %d\n",tm,m->tm);
  if ( tm < m->tm+40 )  return;
	m->tm = tm;

  if ( m->bt == GLUT_LEFT_BUTTON ) {
		ix = x - m->x;
		iy = y - m->y;
    /* axis of rotation: cross product */
    view_proj(ix,iy,vw->wx,vw->wy,pos);
		m->axis[0] = m->pos[1]*pos[2] - m->pos[2]*pos[1];
		m->axis[1] = m->pos[2]*pos[0] - m->pos[0]*pos[2];
		m->axis[2] = m->pos[0]*pos[1] - m->pos[1]*pos[0];
		dx = pos[0] - m->pos[0];
		dy = pos[1] - m->pos[1];
		dz = pos[2] - m->pos[2];

		m->ang    = 180.0*sqrt(dx*dx + dy*dy + dz*dz);
		m->pos[0] = pos[0];
		m->pos[1] = pos[1];
		m->pos[2] = pos[2];
		printf("-->angle %f\n",m->ang);
		glutPostRedisplay();
	}
  else if ( m->bt == GLUT_MIDDLE_BUTTON ) {
  }
}

static void view_mouse(int button,int state,int x,int y) {
  View    *vw;
  Mouse   *m;
	int      id,ix,iy;

  if ( cv.ddb )  fprintf(stdout,"  - control mouse %d\n",state);
	id = view_id();
  assert(id > -1);

  vw = cv.view[id];
  m  = &cv.mouse;
  m->tm = glutGet(GLUT_ELAPSED_TIME);

	if ( state == GLUT_DOWN ) {
		m->x = x;
		m->y = y;
		m->bt = button;
		if ( button == GLUT_LEFT_BUTTON ) {
			ix = x - m->x;
			iy = y - m->y;
			view_proj(ix,iy,vw->wx,vw->wy,m->pos);
		}
	}
	else if ( state == GLUT_UP ) {
	}

	glutPostRedisplay();
}

/* default reshape routine */
static void view_reshape(int wx,int wy) {
  View    *vw;
  double   ratio;
  int      id;

	id = view_id();
  assert(id > -1);
	if ( cv.ddb )  fprintf(stdout,"  - reshape view [%d]\n",id);
  vw = cv.view[id];

	vw->wx = wx;
	vw->wy = wy;
	glViewport(0,0,wx,wy);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	ratio = (double)vw->wx / vw->wy;

	gluPerspective(vw->fovy,ratio,0.025,50.0);
	glTranslatef(0.,0.,-2);
}

/* default display routine (mono) */
static void view_display() {
  View   *vw;
	Mouse  *m;
	int     id;

	id = view_id();
  assert(id > -1);
	if ( cv.ddb )  fprintf(stdout,"  - display view [%d]\n",id);
  vw = cv.view[id];
  m  = &cv.mouse;
fprintf(stdout,"mouse %d  %d\n",m->x,m->y);

  /* mono display */
  glDrawBuffer(GL_BACK_LEFT);
	glClearColor(vw->bk[0]*IGL_RVBN,vw->bk[1]*IGL_RVBN,vw->bk[2]*IGL_RVBN,1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  /* store rotation matrix */
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

	/* keep old transformation */
	memcpy(vw->omat,vw->cmat,16*sizeof(float));
fprintf(stdout,"angle %f\n",m->ang);

	/* compute new transformation */
	if ( fabs(m->ang) > 0.0 ) {
	  glPushMatrix();
	  glRotatef(m->ang,m->axis[0],m->axis[1],m->axis[2]);
	  glMultMatrixf(vw->cmat);
	  glGetFloatv(GL_MODELVIEW_MATRIX,vw->cmat);
    glPopMatrix();
	  m->ang = 0;
  }
	else {
		/* current transformation */
	  glMultMatrixf(vw->cmat);
  }
  glPushMatrix();

  glEnable(GL_LIGHTING);
  glEnable(GL_COLOR_MATERIAL);
  glEnable(GL_POLYGON_OFFSET_FILL);
  glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);

  /* draw bounding box */
  glColor3f(0.8,0.6,1.0);
	glLineWidth(2.0);
  glutSolidCube(1.0);

  /* here call draw objects */


  /* view matrix+refresh */
	glPopMatrix();
  glutSwapBuffers();
	
	icsgl_error();
}

/* initialization routine */
static void view_init() {
  GLfloat  lightamb[4] = { 0.1, 0.1, 0.1, 1.0 };
  GLfloat  lightdif[4] = { 1.0, 1.0, 1.0, 1.0 };
  GLfloat  lightpos[4] = { 1.0, 1.0, 0.8, 1.0 };

  /* openGL basic calls */
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LEQUAL);
  glPolygonOffset(1.0, 1.0 / (float)0x10000);
  glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
  glShadeModel(GL_SMOOTH);
  glDisable(GL_NORMALIZE);
  glDisable(GL_LINE_SMOOTH);
  glDisable(GL_POINT_SMOOTH);
  glDisable(GL_DITHER);
  glDisable(GL_CULL_FACE);

  /* lighting */
  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_TRUE);
  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_FALSE);
  glLightfv(GL_LIGHT0,GL_DIFFUSE,lightdif);
  glLightfv(GL_LIGHT0,GL_AMBIENT,lightamb);
  glEnable(GL_LIGHTING);
  glLightfv(GL_LIGHT0,GL_POSITION,lightpos);
  glEnable(GL_LIGHT0);
}

static int view_open(View *vw) {
  int    id;
  char   data[64];

  glutInitWindowSize(vw->wx,vw->wy);
  id = glutCreateWindow("");
  sprintf(data,"View [%d]",id);
  glutSetWindowTitle(data);
  glutSetIconTitle(data);
	
	/* set background */
  glutDisplayFunc(view_display);
	glutReshapeFunc(view_reshape);
	glutMouseFunc(view_mouse);
	glutMotionFunc(view_motion);

  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glRotatef(-60.,1.,0.,0.);
  glRotatef(-120.,0.,0.,1.);
	glGetFloatv(GL_MODELVIEW_MATRIX,vw->cmat);
  glPopMatrix();

	return(id);
}


/* external calls */
void icsglEvent(int event) {
  View    *vw;
  int      i;

	switch (event) {
		case IGL_DISPLAY:
		  for (i=0; i<cv.nbs; i++) {
				vw = cv.view[i];
			  if ( !vw->on ) {
					vw->id = view_open(vw);
					view_init();
				}
			  
		  }
		  break;
		case IGL_RESHAPE:
		  break;
	}
}

/* create a scene in canvas */
int icsglView_add(double *bb,void *display) {
  View     *vw;
  //GLfloat   bk[4] = {52, 90, 108};
  GLfloat   bk[4] = {254, 254, 254};

	cv.ids = (cv.ids+1) % IGL_MAX_VIEW;
	cv.nbs = cv.nbs < IGL_MAX_VIEW ? cv.nbs+1 : IGL_MAX_VIEW;

	/* memory allocation */
	vw = cv.view[cv.ids];
	if ( vw != NULL ) {
  	free(cv.view[cv.ids]);
		cv.view[cv.ids] = NULL;
  }
  vw = (View*)calloc(1,sizeof(View));
	assert(vw);
	cv.view[cv.ids] = vw;

  vw->wx   = IGL_WIDTH;
	vw->wy   = IGL_HEIGHT;
	vw->fovy = 60.0;
	memcpy(vw->bb,bb,6*sizeof(double));
  memcpy(vw->bk,bk,3*sizeof(GLfloat));

	return(cv.ids);
}

/* parse args for graphic instructions */
static void iglParseArgs(int argc,char *argv[],Canvas *cv) {
  int      i;

  /* set defaults */
	memset(cv,0,sizeof(Canvas));
	cv->nbs  =  0;
  cv->ids  = -1;
  cv->mode = GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH;

  i = 1;
  while ( i < argc ) {
    if ( *argv[i] == '-' ) {
      switch(argv[i][1]) {
				case 'd':
				  cv->ddb = 1;
				break;
        case 's':
			    if ( !strcmp(argv[i],"--stereo") ) {
            cv->mode |= IGL_STEREO;
				  }
        break;
	    }
		}
	  i++;
	}
}

/* main routine to init graphics */
void icsglInit(int argc,char *argv[]) {

  cv.mouse.ang = 0;
  /* parse arguments */
  iglParseArgs(argc,argv,&cv);
  glutInit(&argc,argv);
  glutInitDisplayMode(cv.mode);
}


